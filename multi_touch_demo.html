<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Multi-Touch Visualizer **v5** - **æ‹–åŠ¨=å½¢çŠ¶æ´»å˜æŠ–åŠ¨**ï¼**è¶…è‡ªç„¶**ï¼</title>
    <style>
        * { margin: 0; padding: 0; overflow: hidden; }
        body { background: black; touch-action: none; font-family: -apple-system, sans-serif; }
        canvas { display: block; cursor: none; }
        #info {
            position: fixed; top: 10px; left: 10px; color: lime; font-size: 16px; z-index: 10;
            pointer-events: none; user-select: none; background: rgba(0,0,0,0.9); padding: 15px; border-radius: 12px;
            box-shadow: 0 0 20px lime; border: 2px solid lime;
        }
        @media (max-width: 768px) { #info { font-size: 14px; } }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">
        <div>ğŸ‘† æ‰‹æŒ‡: <span id="touchCount">0</span> | æ€»é¢ç§¯: <span id="totalArea">0</span></div>
        <div>ğŸ® **v5 ç¥ä½œ**ï¼š**æ‹–åŠ¨æ‰‹=å½¢çŠ¶** **å®æ—¶æŠ–å˜**ï¼**ä¸è·Ÿéšï¼Œæ­»å˜åŒ–**ï¼<br>ğŸ’¥ **è‡ªç„¶å¦‚çœŸä¼ æ„Ÿå™¨**ï¼**5æŒ‡ç‹‚æ‹–**çœ‹**å½¢çŠ¶ç‹‚èˆ**ï¼</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const touchCountEl = document.getElementById('touchCount');
        const totalAreaEl = document.getElementById('totalArea');

        // å¤§åƒç´ ä½åˆ†è¾¨ç‡
        const GRID_SIZE = 120;
        let pixelSize = 1;
        let offsetX = 0, offsetY = 0;
        let touches = new Map(); // id -> {centerX,Y, seed, force}
        let startTime = Date.now();

        function noise(x, y = 0, seed = 0) {
            x += seed * 17.3;
            let n = 0, a = 1;
            for (let i = 0; i < 5; i++) {
                n += a * (Math.sin(x * 12.9898 + y * 78.233) * 43758.5453 % 1);
                a *= 0.5; x *= 2.1; y *= 2.0;
            }
            return n % 1;
        }

        // ğŸ”¥ **å®æ—¶åŠ¨æ€å½¢çŠ¶å‡½æ•°**ï¼šä½ç½®+æ—¶é—´=æ°¸å˜ï¼
        function computeDynamicShape(dx, dy, seed, time, force) {
            // **éšæœºæ—‹è½¬/ç¼©æ”¾/å€¾æ–œ** (timeé©±åŠ¨)
            const wiggle = noise(time * 2 + seed) * 0.3;
            const rot = (noise(seed) + wiggle * 0.5) * Math.PI * 2;
            const scaleX = 1.2 + noise(seed + 10 + time) * 0.8;
            const scaleY = 1.5 + noise(seed + 20 + time * 1.3) * 1.0;
            const skew = (noise(seed + 30 + time * 0.7) - 0.5) * 0.4;

            // **å˜æ¢åæ ‡**
            let rx = dx / scaleX;
            let ry = dy / scaleY;
            rx += ry * skew;

            const ca = Math.cos(rot), sa = Math.sin(rot);
            const tx = rx * ca - ry * sa;
            const ty = rx * sa + ry * ca;

            // **åŒå³°ä¸è§„åˆ™ + æ—¶é—´æŠ–åŠ¨å™ªå£°**
            const dist1 = Math.sqrt(tx*tx / (0.9)**2 + ty*ty / (1.2)**2);
            const dist2 = Math.sqrt((tx - 0.4 + wiggle)**2 / 0.5**2 + (ty + 0.3)**2 / 0.7**2);
            let val = Math.max( Math.exp(-dist1 * 3.5), Math.exp(-dist2 * 4) * 0.7 );

            // **å¤šå±‚æ¯›ç³™ + æ—¶é—´è„‰åŠ¨**
            val *= (0.7 + noise(dx*0.3 + time, dy*0.3 + time, seed) * 0.5);
            val *= (0.85 + noise(dx*0.6, dy*0.6, seed + 100 + time*3) * 0.3);
            val *= force * (0.9 + Math.sin(time * 4 + seed) * 0.1); // å¾®è„‰åŠ¨

            return Math.max(0, val);
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const size = Math.min(canvas.width, canvas.height);
            pixelSize = size / GRID_SIZE;
            offsetX = (canvas.width - size) / 2;
            offsetY = (canvas.height - size) / 2;
        }

        function getTouchPos(touch) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: ((touch.clientX - rect.left) - offsetX) / pixelSize,
                y: ((touch.clientY - rect.top) - offsetY) / pixelSize
            };
        }

        function onTouchStart(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                const pos = getTouchPos(touch);
                const seed = Date.now() * 0.001 + touch.identifier * 100;
                const force = 0.6 + noise(seed + 300) * 0.8;
                touches.set(touch.identifier, { centerX: pos.x, centerY: pos.y, seed, force });
            }
            updateDisplay();
        }

        function onTouchMove(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                const touchData = touches.get(touch.identifier);
                if (touchData) {
                    const pos = getTouchPos(touch);
                    touchData.centerX = pos.x;
                    touchData.centerY = pos.y;
                    // **forceå¾®å˜** (æ¨¡æ‹ŸæŒ‰å‹)
                    touchData.force = 0.5 + (Math.sin(Date.now() * 0.01) * 0.2 + 0.3);
                }
            }
            updateDisplay();
        }

        function onTouchEnd(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                touches.delete(touch.identifier);
            }
            updateDisplay();
        }

        function updateDisplay() {
            touchCountEl.textContent = touches.size;
            let totalArea = 0;
            touches.forEach(t => totalArea += t.force * 250);
            totalAreaEl.textContent = Math.floor(totalArea);
            render();
        }

        function render() {
            const time = (Date.now() - startTime) * 0.001;

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const gridLeft = offsetX, gridTop = offsetY;
            for (let gy = 0; gy < GRID_SIZE; gy++) {
                for (let gx = 0; gx < GRID_SIZE; gx++) {
                    let maxBright = 0;
                    let closestTouchId = -1;
                    let minDist = Infinity;

                    touches.forEach((touch, id) => {
                        const dx = (gx + 0.5) - touch.centerX;
                        const dy = (gy + 0.5) - touch.centerY;
                        const dist = Math.sqrt(dx*dx + dy*dy);

                        const bright = computeDynamicShape(dx, dy, touch.seed, time, touch.force);

                        if (bright > maxBright) {
                            maxBright = bright;
                            if (dist < minDist) {
                                minDist = dist;
                                closestTouchId = id;
                            }
                        }
                    });

                    if (maxBright > 0.08) {
                        const px = gridLeft + gx * pixelSize;
                        const py = gridTop + gy * pixelSize;
                        const gray = Math.floor(maxBright * 255);
                        ctx.fillStyle = `rgb(${gray},${gray},${gray})`;
                        ctx.fillRect(px, py, pixelSize, pixelSize);

                        // **æ ¸å¿ƒç»¿æ¡†ï¼šæœ€è¿‘æœ€äº®**
                        if (closestTouchId !== -1 && minDist < 1.5) {
                            ctx.fillStyle = 'white';
                            ctx.fillRect(px + pixelSize*0.05, py + pixelSize*0.05, pixelSize*0.9, pixelSize*0.9);

                            ctx.strokeStyle = 'lime';
                            ctx.lineWidth = Math.max(3.5, pixelSize * 0.6);
                            ctx.lineCap = 'round';
                            ctx.strokeRect(px + pixelSize*0.1, py + pixelSize*0.1, pixelSize*0.8, pixelSize*0.8);

                            // **é»‘ç¼–å·è¶…é†’ç›®**
                            ctx.fillStyle = 'black';
                            ctx.font = `${pixelSize}px bold monospace`;
                            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                            ctx.fillText(
                                (Array.from(touches.keys()).indexOf(closestTouchId) + 1) + '',
                                px + pixelSize/2, py + pixelSize/2 + 0.5
                            );
                        }
                    }
                }
            }
        }

        // äº‹ä»¶
        canvas.addEventListener('touchstart', onTouchStart, { passive: false });
        canvas.addEventListener('touchmove', onTouchMove, { passive: false });
        canvas.addEventListener('touchend', onTouchEnd, { passive: false });
        canvas.addEventListener('touchcancel', onTouchEnd, { passive: false });

        // é¼ æ ‡
        let mouseActive = false;
        canvas.addEventListener('mousedown', (e) => {
            mouseActive = true;
            onTouchStart({ changedTouches: [{identifier: 999, clientX: e.clientX, clientY: e.clientY}] });
        });
        canvas.addEventListener('mousemove', (e) => {
            if (mouseActive) onTouchMove({ changedTouches: [{identifier: 999, clientX: e.clientX, clientY: e.clientY}] });
        });
        canvas.addEventListener('mouseup', () => {
            mouseActive = false;
            onTouchEnd({ changedTouches: [{identifier: 999}] });
        });

        window.addEventListener('resize', resize);
        window.addEventListener('orientationchange', () => setTimeout(resize, 100));
        resize();
        updateDisplay(); // åˆå§‹é»‘å±

        // **åŠ¨ç”»å¾ªç¯ï¼š60FPS æ´»å˜**
        function loop() {
            updateDisplay();
            requestAnimationFrame(loop);
        }
        loop();
    </script>
</body>
</html>
