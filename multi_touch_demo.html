<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Multi-Touch Visualizer **v7** - **è¶…å·¨åƒç´ 50px+ï¼**Retinaé”åˆ©ï¼</title>
    <style>
        * { margin: 0; padding: 0; overflow: hidden; }
        body { background: black; touch-action: none; font-family: -apple-system, sans-serif; }
        canvas { display: block; cursor: none; image-rendering: pixelated; image-rendering: -moz-crisp-edges; }
        #info {
            position: fixed; top: 10px; left: 10px; color: lime; font-size: 20px; z-index: 10;
            pointer-events: none; user-select: none; background: rgba(0,0,0,0.95); padding: 25px; border-radius: 20px;
            box-shadow: 0 0 40px lime; border: 4px solid lime;
        }
        @media (max-width: 768px) { #info { font-size: 18px; padding: 20px; } }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">
        <div>ğŸ‘† æ‰‹æŒ‡: <span id="touchCount">0</span> | é¢ç§¯: <span id="totalArea">0</span></div>
        <div>ğŸ“ **åƒç´ : <span id="pixelInfo">??</span>px** | **v7 æ ¸å¼¹çº§**ï¼**50pxå·¨ç –**ï¼**æ‹–åŠ¨ç‹‚èˆ**ï¼<br>ğŸ’¥ **iPad Proå…¨å±** **æ‹³å¤´å¤§æ ¼å­**ï¼**çœ‹æ¸…æ¯ä¸æŠ–åŠ¨**ï¼</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const touchCountEl = document.getElementById('touchCount');
        const totalAreaEl = document.getElementById('totalArea');
        const pixelInfoEl = document.getElementById('pixelInfo');

        // ğŸ”¥ **æ ¸å¼¹çº§å·¨åƒç´ ï¼š50x50 = æ¯ä¸ª50-60pxï¼**
        const GRID_SIZE = 50;
        let pixelSize = 1;
        let dpr = 1; // Retinaæ”¯æŒ
        let offsetX = 0, offsetY = 0;
        let touches = new Map();
        let startTime = Date.now();

        function noise(x, y = 0, seed = 0) {
            x += seed * 17.3; let n = 0, a = 1;
            for (let i = 0; i < 6; i++) {
                n += a * (Math.sin(x * 12.9898 + y * 78.233) * 43758.5453 % 1);
                a *= 0.5; x *= 2.1; y *= 2.0;
            }
            return n % 1;
        }

        function computeDynamicShape(dx, dy, seed, time, force) {
            const wiggle = noise(time * 4 + seed) * 0.5;
            const rot = (noise(seed) + wiggle * 1.2) * Math.PI * 2;
            const scaleX = 1.6 + noise(seed + 10 + time * 2) * 1.2;
            const scaleY = 1.9 + noise(seed + 20 + time * 2.5) * 1.4;
            const skew = (noise(seed + 30 + time * 1.5) - 0.5) * 0.6;

            let rx = dx / scaleX;
            let ry = dy / scaleY;
            rx += ry * skew;

            const ca = Math.cos(rot), sa = Math.sin(rot);
            const tx = rx * ca - ry * sa;
            const ty = rx * sa + ry * ca;

            const dist1 = Math.sqrt(tx*tx / 1.1**2 + ty*ty / 1.5**2);
            const dist2 = Math.sqrt((tx - 0.6 + wiggle)**2 / 0.7**2 + (ty + 0.5)**2 / 0.9**2);
            let val = Math.max( Math.exp(-dist1 * 2.8), Math.exp(-dist2 * 3.2) * 0.85 );

            val *= (0.8 + noise(dx*0.5 + time * 3, dy*0.5 + time * 3, seed) * 0.4);
            val *= (0.92 + noise(dx*1.0, dy*1.0, seed + 100 + time*5) * 0.16);
            val *= force * (0.98 + Math.sin(time * 6 + seed) * 0.12);

            return Math.max(0, val);
        }

        function resize() {
            const rect = canvas.getBoundingClientRect();
            dpr = window.devicePixelRatio || 1;
            const width = window.innerWidth * dpr;
            const height = window.innerHeight * dpr;

            canvas.width = width;
            canvas.height = height;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';

            ctx.scale(dpr, dpr); // **Retinaé”åˆ©ï¼**

            const size = Math.min(window.innerWidth, window.innerHeight);
            pixelSize = size / GRID_SIZE; // **é€»è¾‘åƒç´  ~50pxï¼**
            offsetX = (window.innerWidth - size) / 2;
            offsetY = (window.innerHeight - size) / 2;

            pixelInfoEl.textContent = Math.round(pixelSize) + 'px';
        }

        function getTouchPos(touch) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: ((touch.clientX - rect.left) - offsetX) / pixelSize,
                y: ((touch.clientY - rect.top) - offsetY) / pixelSize
            };
        }

        function onTouchStart(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                const pos = getTouchPos(touch);
                const seed = Date.now() * 0.001 + touch.identifier * 100;
                const force = 0.75 + noise(seed + 300) * 0.5;
                touches.set(touch.identifier, { centerX: pos.x, centerY: pos.y, seed, force });
            }
            updateDisplay();
        }

        function onTouchMove(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                const touchData = touches.get(touch.identifier);
                if (touchData) {
                    const pos = getTouchPos(touch);
                    touchData.centerX = pos.x;
                    touchData.centerY = pos.y;
                    touchData.force = 0.65 + Math.sin(Date.now() * 0.006 + touch.identifier) * 0.35;
                }
            }
            updateDisplay();
        }

        function onTouchEnd(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                touches.delete(touch.identifier);
            }
            updateDisplay();
        }

        function updateDisplay() {
            touchCountEl.textContent = touches.size;
            let totalArea = 0;
            touches.forEach(t => totalArea += t.force * 400);
            totalAreaEl.textContent = Math.floor(totalArea);
        }

        function render() {
            const time = (Date.now() - startTime) * 0.001;

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);

            const gridLeft = offsetX, gridTop = offsetY;
            for (let gy = 0; gy < GRID_SIZE; gy++) {
                for (let gx = 0; gx < GRID_SIZE; gx++) {
                    let maxBright = 0;
                    let closestTouchId = -1;
                    let minDist = Infinity;

                    touches.forEach((touch, id) => {
                        const dx = (gx + 0.5) - touch.centerX;
                        const dy = (gy + 0.5) - touch.centerY;
                        const dist = Math.sqrt(dx*dx + dy*dy);

                        const bright = computeDynamicShape(dx, dy, touch.seed, time, touch.force);

                        if (bright > maxBright) {
                            maxBright = bright;
                            if (dist < minDist) {
                                minDist = dist;
                                closestTouchId = id;
                            }
                        }
                    });

                    if (maxBright > 0.12) {
                        const px = gridLeft + gx * pixelSize;
                        const py = gridTop + gy * pixelSize;
                        const gray = Math.floor(maxBright * 255);
                        ctx.fillStyle = `rgb(${gray},${gray},${gray})`;
                        ctx.fillRect(px, py, pixelSize, pixelSize);

                        if (closestTouchId !== -1 && minDist < 2.0) {
                            ctx.fillStyle = 'white';
                            ctx.fillRect(px + pixelSize*0.03, py + pixelSize*0.03, pixelSize*0.94, pixelSize*0.94);

                            ctx.strokeStyle = 'lime';
                            ctx.lineWidth = Math.max(8, pixelSize * 1.0); // **å·¨ç²—ï¼**
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';
                            ctx.strokeRect(px + pixelSize*0.08, py + pixelSize*0.08, pixelSize*0.84, pixelSize*0.84);

                            ctx.fillStyle = 'black';
                            ctx.font = `${pixelSize*1.4}px bold Arial Black, Impact, monospace`;
                            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                            ctx.fillText(
                                (Array.from(touches.keys()).indexOf(closestTouchId) + 1) + '',
                                px + pixelSize/2, py + pixelSize/2
                            );
                        }
                    }
                }
            }
        }

        // äº‹ä»¶
        canvas.addEventListener('touchstart', onTouchStart, { passive: false });
        canvas.addEventListener('touchmove', onTouchMove, { passive: false });
        canvas.addEventListener('touchend', onTouchEnd, { passive: false });
        canvas.addEventListener('touchcancel', onTouchEnd, { passive: false });

        // é¼ æ ‡
        let mouseActive = false;
        canvas.addEventListener('mousedown', (e) => {
            mouseActive = true;
            onTouchStart({ changedTouches: [{identifier: 999, clientX: e.clientX, clientY: e.clientY}] });
        });
        canvas.addEventListener('mousemove', (e) => {
            if (mouseActive) onTouchMove({ changedTouches: [{identifier: 999, clientX: e.clientX, clientY: e.clientY}] });
        });
        canvas.addEventListener('mouseup', () => {
            mouseActive = false;
            onTouchEnd({ changedTouches: [{identifier: 999}] });
        });

        window.addEventListener('resize', resize);
        window.addEventListener('orientationchange', () => setTimeout(resize, 100));
        resize();

        function loop() {
            updateDisplay();
            render();
            requestAnimationFrame(loop);
        }
        loop();
    </script>
</body>
</html>
