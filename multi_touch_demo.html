<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Multi-Touch Visualizer **v6** - **è¶…å¤§åƒç´ ï¼å·¨æ¸…æ™°**ï¼</title>
    <style>
        * { margin: 0; padding: 0; overflow: hidden; }
        body { background: black; touch-action: none; font-family: -apple-system, sans-serif; }
        canvas { display: block; cursor: none; }
        #info {
            position: fixed; top: 10px; left: 10px; color: lime; font-size: 18px; z-index: 10;
            pointer-events: none; user-select: none; background: rgba(0,0,0,0.9); padding: 20px; border-radius: 15px;
            box-shadow: 0 0 30px lime; border: 3px solid lime;
        }
        @media (max-width: 768px) { #info { font-size: 16px; padding: 15px; } }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">
        <div>ğŸ‘† æ‰‹æŒ‡: <span id="touchCount">0</span> | æ€»é¢ç§¯: <span id="totalArea">0</span></div>
        <div>ğŸ”¥ **v6 å·¨å±æ¸…æ™°ç‰ˆ**ï¼š**æ¯ä¸ªåƒç´ 20px+**ï¼**è¶…å¤§å—**ï¼**æ‹–åŠ¨ç‹‚å˜**ï¼<br>ğŸ’¥ **iPadå…¨å±çœ‹æ¸…æ¯ä¸ªç»†èŠ‚**ï¼**5æŒ‡è¯•è¯•**ï¼</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const touchCountEl = document.getElementById('touchCount');
        const totalAreaEl = document.getElementById('totalArea');

        // ğŸ”¥ **è¶…ä½åˆ†è¾¨ç‡ï¼š80x80 = å·¨åƒç´ ï¼20-30px/æ ¼**ï¼
        const GRID_SIZE = 80;
        let pixelSize = 1;
        let offsetX = 0, offsetY = 0;
        let touches = new Map();
        let startTime = Date.now();

        function noise(x, y = 0, seed = 0) {
            x += seed * 17.3;
            let n = 0, a = 1;
            for (let i = 0; i < 5; i++) {
                n += a * (Math.sin(x * 12.9898 + y * 78.233) * 43758.5453 % 1);
                a *= 0.5; x *= 2.1; y *= 2.0;
            }
            return n % 1;
        }

        // **å®æ—¶åŠ¨æ€å·¨å½¢**ï¼šæ—¶é—´é©±åŠ¨ç‹‚å˜ï¼
        function computeDynamicShape(dx, dy, seed, time, force) {
            const wiggle = noise(time * 3 + seed) * 0.4;
            const rot = (noise(seed) + wiggle) * Math.PI * 2;
            const scaleX = 1.4 + noise(seed + 10 + time * 1.5) * 1.0;
            const scaleY = 1.7 + noise(seed + 20 + time * 2) * 1.2;
            const skew = (noise(seed + 30 + time) - 0.5) * 0.5;

            let rx = dx / scaleX;
            let ry = dy / scaleY;
            rx += ry * skew;

            const ca = Math.cos(rot), sa = Math.sin(rot);
            const tx = rx * ca - ry * sa;
            const ty = rx * sa + ry * ca;

            const dist1 = Math.sqrt(tx*tx / 1.0**2 + ty*ty / 1.4**2);
            const dist2 = Math.sqrt((tx - 0.5 + wiggle)**2 / 0.6**2 + (ty + 0.4)**2 / 0.8**2);
            let val = Math.max( Math.exp(-dist1 * 3), Math.exp(-dist2 * 3.5) * 0.8 );

            val *= (0.75 + noise(dx*0.4 + time * 2, dy*0.4 + time * 2, seed) * 0.5);
            val *= (0.9 + noise(dx*0.8, dy*0.8, seed + 100 + time*4) * 0.2);
            val *= force * (0.95 + Math.sin(time * 5 + seed) * 0.15);

            return Math.max(0, val);
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const size = Math.min(canvas.width, canvas.height);
            pixelSize = size / GRID_SIZE; // **ç°åœ¨~25px/æ ¼ï¼å·¨æ¸…ï¼**
            offsetX = (canvas.width - size) / 2;
            offsetY = (canvas.height - size) / 2;
        }

        function getTouchPos(touch) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: ((touch.clientX - rect.left) - offsetX) / pixelSize,
                y: ((touch.clientY - rect.top) - offsetY) / pixelSize
            };
        }

        function onTouchStart(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                const pos = getTouchPos(touch);
                const seed = Date.now() * 0.001 + touch.identifier * 100;
                const force = 0.7 + noise(seed + 300) * 0.6;
                touches.set(touch.identifier, { centerX: pos.x, centerY: pos.y, seed, force });
            }
            updateDisplay();
        }

        function onTouchMove(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                const touchData = touches.get(touch.identifier);
                if (touchData) {
                    const pos = getTouchPos(touch);
                    touchData.centerX = pos.x;
                    touchData.centerY = pos.y;
                    touchData.force = 0.6 + Math.sin(Date.now() * 0.005 + touch.identifier) * 0.4;
                }
            }
            updateDisplay();
        }

        function onTouchEnd(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                touches.delete(touch.identifier);
            }
            updateDisplay();
        }

        function updateDisplay() {
            touchCountEl.textContent = touches.size;
            let totalArea = 0;
            touches.forEach(t => totalArea += t.force * 300);
            totalAreaEl.textContent = Math.floor(totalArea);
        }

        function render() {
            const time = (Date.now() - startTime) * 0.001;

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const gridLeft = offsetX, gridTop = offsetY;
            for (let gy = 0; gy < GRID_SIZE; gy++) {
                for (let gx = 0; gx < GRID_SIZE; gx++) {
                    let maxBright = 0;
                    let closestTouchId = -1;
                    let minDist = Infinity;

                    touches.forEach((touch, id) => {
                        const dx = (gx + 0.5) - touch.centerX;
                        const dy = (gy + 0.5) - touch.centerY;
                        const dist = Math.sqrt(dx*dx + dy*dy);

                        const bright = computeDynamicShape(dx, dy, touch.seed, time, touch.force);

                        if (bright > maxBright) {
                            maxBright = bright;
                            if (dist < minDist) {
                                minDist = dist;
                                closestTouchId = id;
                            }
                        }
                    });

                    if (maxBright > 0.1) { // é˜ˆå€¼ä¸Šè°ƒï¼Œå‡å°‘å™ªç‚¹
                        const px = gridLeft + gx * pixelSize;
                        const py = gridTop + gy * pixelSize;
                        const gray = Math.floor(maxBright * 255);
                        ctx.fillStyle = `rgb(${gray},${gray},${gray})`;
                        ctx.fillRect(px, py, pixelSize, pixelSize);

                        // **å·¨ç»¿æ¡†ï¼šè¶…ç²—+å¤§å·ï¼**
                        if (closestTouchId !== -1 && minDist < 1.8) {
                            ctx.fillStyle = 'white';
                            ctx.fillRect(px + pixelSize*0.05, py + pixelSize*0.05, pixelSize*0.9, pixelSize*0.9);

                            ctx.strokeStyle = 'lime';
                            ctx.lineWidth = Math.max(5, pixelSize * 0.8); // **è¶…ç²—çº¿ï¼**
                            ctx.lineCap = 'round';
                            ctx.strokeRect(px + pixelSize*0.1, py + pixelSize*0.1, pixelSize*0.8, pixelSize*0.8);

                            // **å·¨é»‘å·ï¼šè¡€é†’ç›®ï¼**
                            ctx.fillStyle = 'black';
                            ctx.font = `${pixelSize*1.2}px bold Arial Black, monospace`;
                            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                            ctx.fillText(
                                (Array.from(touches.keys()).indexOf(closestTouchId) + 1) + '',
                                px + pixelSize/2, py + pixelSize/2
                            );
                        }
                    }
                }
            }
        }

        // äº‹ä»¶ç»‘å®š
        canvas.addEventListener('touchstart', onTouchStart, { passive: false });
        canvas.addEventListener('touchmove', onTouchMove, { passive: false });
        canvas.addEventListener('touchend', onTouchEnd, { passive: false });
        canvas.addEventListener('touchcancel', onTouchEnd, { passive: false });

        // é¼ æ ‡æ”¯æŒ
        let mouseActive = false;
        canvas.addEventListener('mousedown', (e) => {
            mouseActive = true;
            onTouchStart({ changedTouches: [{identifier: 999, clientX: e.clientX, clientY: e.clientY}] });
        });
        canvas.addEventListener('mousemove', (e) => {
            if (mouseActive) onTouchMove({ changedTouches: [{identifier: 999, clientX: e.clientX, clientY: e.clientY}] });
        });
        canvas.addEventListener('mouseup', () => {
            mouseActive = false;
            onTouchEnd({ changedTouches: [{identifier: 999}] });
        });

        window.addEventListener('resize', resize);
        window.addEventListener('orientationchange', () => setTimeout(resize, 100));
        resize();

        // **åŠ¨ç”»å¾ªç¯**
        function loop() {
            render();
            requestAnimationFrame(loop);
        }
        loop();
    </script>
</body>
</html>
