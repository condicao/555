<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Multi-Touch Visualizer **v9** - **å®Œç¾40px**ï¼**æ— æ•°å­—**ï¼**æ…¢å˜ä¼˜é›…**ï¼</title>
    <style>
        * { margin: 0; padding: 0; overflow: hidden; }
        body { background: black; touch-action: none; font-family: -apple-system, sans-serif; }
        canvas { 
            display: block; 
            cursor: none; 
            image-rendering: pixelated; 
            image-rendering: -moz-crisp-edges; 
            image-rendering: crisp-edges;
        }
        #info {
            position: fixed; top: 15px; left: 15px; color: lime; font-size: 22px; z-index: 10;
            pointer-events: none; user-select: none; background: rgba(0,0,0,0.98); padding: 25px; border-radius: 20px;
            box-shadow: 0 0 40px lime; border: 4px solid lime;
        }
        @media (max-width: 768px) { #info { font-size: 18px; padding: 20px; } }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">
        <div>ğŸ‘† æ‰‹æŒ‡: <span id="touchCount">0</span></div>
        <div>ğŸ“ **åƒç´ : <span id="pixelInfo">??</span>px** | **v9 ä¼˜é›…ç‰ˆ**ï¼**40pxå®Œç¾**ï¼**æ…¢å˜æ¢¦å¹»**ï¼<br>ğŸ’¥ **æ— æ•°å­—**ï¼**çº¯ç»¿æ¡†**ï¼**æ‹–åŠ¨çœ‹ä¼˜é›…èˆåŠ¨**ï¼</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const touchCountEl = document.getElementById('touchCount');
        const pixelInfoEl = document.getElementById('pixelInfo');

        // ğŸ”¥ **å®Œç¾å¹³è¡¡ï¼š25x25 = ~40px/æ ¼ï¼é€‚ä¸­å·¨æ¸…ï¼**
        const GRID_SIZE = 25;
        let pixelSize = 1;
        let dpr = 1;
        let offsetX = 0, offsetY = 0;
        let touches = new Map();
        let startTime = Date.now();

        function noise(x, y = 0, seed = 0) {
            x += seed * 17.3; let n = 0, a = 1;
            for (let i = 0; i < 6; i++) {
                n += a * (Math.sin(x * 12.9898 + y * 78.233) * 43758.5453 % 1);
                a *= 0.5; x *= 2.1; y *= 2.0;
            }
            return n % 1;
        }

        // **æ…¢å˜ä¼˜é›…ï¼štime * 0.5 = 2Xæ…¢ï¼**
        function computeDynamicShape(dx, dy, seed, time, force) {
            const wiggle = noise(time * 1.5 + seed) * 0.4; // **æ…¢wiggle**
            const rot = (noise(seed) + wiggle) * Math.PI * 2;
            const scaleX = 1.8 + noise(seed + 10 + time * 0.8) * 1.4; // **æ…¢scale**
            const scaleY = 2.2 + noise(seed + 20 + time * 1.0) * 1.6;
            const skew = (noise(seed + 30 + time * 0.6) - 0.5) * 0.5;

            let rx = dx / scaleX;
            let ry = dy / scaleY;
            rx += ry * skew;

            const ca = Math.cos(rot), sa = Math.sin(rot);
            const tx = rx * ca - ry * sa;
            const ty = rx * sa + ry * ca;

            const dist1 = Math.sqrt(tx*tx / 1.2**2 + ty*ty / 1.6**2);
            const dist2 = Math.sqrt((tx - 0.6 + wiggle)**2 / 0.7**2 + (ty + 0.4)**2 / 0.9**2);
            let val = Math.max( Math.exp(-dist1 * 2.5), Math.exp(-dist2 * 2.8) * 0.85 );

            val *= (0.78 + noise(dx*0.5 + time * 1.5, dy*0.5 + time * 1.5, seed) * 0.44);
            val *= (0.92 + noise(dx*1.0, dy*1.0, seed + 100 + time*2.5) * 0.16);
            val *= force * (0.96 + Math.sin(time * 2.5 + seed) * 0.08); // **è¶…æ…¢è„‰åŠ¨**

            return Math.max(0, val);
        }

        function resize() {
            dpr = window.devicePixelRatio || 1;
            const width = window.innerWidth * dpr;
            const height = window.innerHeight * dpr;

            canvas.width = width;
            canvas.height = height;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';

            ctx.scale(dpr, dpr);

            const size = Math.min(window.innerWidth, window.innerHeight);
            pixelSize = size / GRID_SIZE; // **~40px é»„é‡‘ï¼**
            offsetX = (window.innerWidth - size) / 2;
            offsetY = (window.innerHeight - size) / 2;

            pixelInfoEl.textContent = Math.round(pixelSize) + 'px';
        }

        function getTouchPos(touch) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: ((touch.clientX - rect.left) - offsetX) / pixelSize,
                y: ((touch.clientY - rect.top) - offsetY) / pixelSize
            };
        }

        function onTouchStart(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                const pos = getTouchPos(touch);
                const seed = Date.now() * 0.001 + touch.identifier * 100;
                const force = 0.75 + noise(seed + 300) * 0.5;
                touches.set(touch.identifier, { centerX: pos.x, centerY: pos.y, seed, force });
            }
            updateDisplay();
        }

        function onTouchMove(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                const touchData = touches.get(touch.identifier);
                if (touchData) {
                    const pos = getTouchPos(touch);
                    touchData.centerX = pos.x;
                    touchData.centerY = pos.y;
                    touchData.force = 0.7 + Math.sin(Date.now() * 0.003 + touch.identifier) * 0.3; // **æ…¢force**
                }
            }
            updateDisplay();
        }

        function onTouchEnd(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                touches.delete(touch.identifier);
            }
            updateDisplay();
        }

        function updateDisplay() {
            touchCountEl.textContent = touches.size;
        }

        function render() {
            const time = (Date.now() - startTime) * 0.0005; // **5Xæ…¢ï¼æ¢¦å¹»èŠ‚å¥**

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);

            const gridLeft = offsetX, gridTop = offsetY;
            for (let gy = 0; gy < GRID_SIZE; gy++) {
                for (let gx = 0; gx < GRID_SIZE; gx++) {
                    let maxBright = 0;
                    let closestTouchId = -1;
                    let minDist = Infinity;

                    touches.forEach((touch, id) => {
                        const dx = (gx + 0.5) - touch.centerX;
                        const dy = (gy + 0.5) - touch.centerY;
                        const dist = Math.sqrt(dx*dx + dy*dy);

                        const bright = computeDynamicShape(dx, dy, touch.seed, time, touch.force);

                        if (bright > maxBright) {
                            maxBright = bright;
                            if (dist < minDist) {
                                minDist = dist;
                                closestTouchId = id;
                            }
                        }
                    });

                    if (maxBright > 0.15) {
                        const px = gridLeft + gx * pixelSize;
                        const py = gridTop + gy * pixelSize;
                        const gray = Math.floor(maxBright * 255);
                        ctx.fillStyle = `rgb(${gray},${gray},${gray})`;
                        ctx.fillRect(px, py, pixelSize, pixelSize);

                        // **çº¯ç»¿æ¡†ï¼šæ— æ•°å­—ï¼ä¼˜é›…åŒ…å›´**
                        if (closestTouchId !== -1 && minDist < 1.8) {
                            // **æ ¸å¿ƒçº¯ç™½**
                            ctx.fillStyle = 'white';
                            ctx.fillRect(px + pixelSize*0.08, py + pixelSize*0.08, pixelSize*0.84, pixelSize*0.84);

                            // **ç²—ç»¿æ¡†ï¼šå‘å…‰èˆ¬**
                            ctx.strokeStyle = 'lime';
                            ctx.lineWidth = Math.max(6, pixelSize * 0.7);
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';
                            ctx.shadowColor = 'lime';
                            ctx.shadowBlur = 8;
                            ctx.strokeRect(px + pixelSize*0.12, py + pixelSize*0.12, pixelSize*0.76, pixelSize*0.76);
                            ctx.shadowBlur = 0; // é‡ç½®
                        }
                    }
                }
            }
        }

        // äº‹ä»¶
        canvas.addEventListener('touchstart', onTouchStart, { passive: false });
        canvas.addEventListener('touchmove', onTouchMove, { passive: false });
        canvas.addEventListener('touchend', onTouchEnd, { passive: false });
        canvas.addEventListener('touchcancel', onTouchEnd, { passive: false });

        // é¼ æ ‡
        let mouseActive = false;
        canvas.addEventListener('mousedown', (e) => {
            mouseActive = true;
            onTouchStart({ changedTouches: [{identifier: 999, clientX: e.clientX, clientY: e.clientY}] });
        });
        canvas.addEventListener('mousemove', (e) => {
            if (mouseActive) onTouchMove({ changedTouches: [{identifier: 999, clientX: e.clientX, clientY: e.clientY}] });
        });
        canvas.addEventListener('mouseup', () => {
            mouseActive = false;
            onTouchEnd({ changedTouches: [{identifier: 999}] });
        });

        window.addEventListener('resize', resize);
        window.addEventListener('orientationchange', () => setTimeout(resize, 100));
        resize();

        function loop() {
            updateDisplay();
            render();
            requestAnimationFrame(loop);
        }
        loop();
    </script>
</body>
</html>
