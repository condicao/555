<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Multi-Touch Visualizer **v8** - **æ ¸çˆ†100px+å·¨ç –**ï¼**5Xç‹‚é£™**ï¼</title>
    <style>
        * { margin: 0; padding: 0; overflow: hidden; }
        body { background: black; touch-action: none; font-family: -apple-system, sans-serif; }
        canvas { 
            display: block; 
            cursor: none; 
            image-rendering: pixelated; 
            image-rendering: -moz-crisp-edges; 
            image-rendering: crisp-edges;
        }
        #info {
            position: fixed; top: 15px; left: 15px; color: lime; font-size: 24px; z-index: 10;
            pointer-events: none; user-select: none; background: rgba(0,0,0,0.98); padding: 30px; border-radius: 25px;
            box-shadow: 0 0 50px lime; border: 5px solid lime;
        }
        @media (max-width: 768px) { #info { font-size: 20px; padding: 25px; } }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">
        <div>ğŸ‘† æ‰‹æŒ‡: <span id="touchCount">0</span> | é¢ç§¯: <span id="totalArea">0</span></div>
        <div>ğŸ“ **åƒç´ : <span id="pixelInfo">??</span>px** | **v8 æ ¸çˆ†**ï¼**100pxå·¨ç –**ï¼**æ‹–åŠ¨ç‹‚èˆ**ï¼<br>ğŸ’¥ **iPadå…¨å±** **æ¯ä¸ªæ ¼å­å·´æŒå¤§**ï¼**ç»¿æ¡†å¦‚åŸå¢™**ï¼</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const touchCountEl = document.getElementById('touchCount');
        const totalAreaEl = document.getElementById('totalArea');
        const pixelInfoEl = document.getElementById('pixelInfo');

        // ğŸ”¥ **æ ¸çˆ†çº§ï¼š12x12 = æ¯ä¸ª~85-130pxå·¨ç –ï¼5X+ï¼**
        const GRID_SIZE = 12;
        let pixelSize = 1;
        let dpr = 1;
        let offsetX = 0, offsetY = 0;
        let touches = new Map();
        let startTime = Date.now();

        function noise(x, y = 0, seed = 0) {
            x += seed * 17.3; let n = 0, a = 1;
            for (let i = 0; i < 6; i++) {
                n += a * (Math.sin(x * 12.9898 + y * 78.233) * 43758.5453 % 1);
                a *= 0.5; x *= 2.1; y *= 2.0;
            }
            return n % 1;
        }

        // **å·¨å½¢ç‹‚å˜ï¼šè¦†ç›–æ›´å¤šæ ¼å­ï¼**
        function computeDynamicShape(dx, dy, seed, time, force) {
            const wiggle = noise(time * 5 + seed) * 0.6;
            const rot = (noise(seed) + wiggle * 1.5) * Math.PI * 2;
            const scaleX = 2.2 + noise(seed + 10 + time * 2.5) * 1.8; // **æ›´å¤§ï¼**
            const scaleY = 2.8 + noise(seed + 20 + time * 3) * 2.2;
            const skew = (noise(seed + 30 + time * 2) - 0.5) * 0.7;

            let rx = dx / scaleX;
            let ry = dy / scaleY;
            rx += ry * skew;

            const ca = Math.cos(rot), sa = Math.sin(rot);
            const tx = rx * ca - ry * sa;
            const ty = rx * sa + ry * ca;

            // **è¶…å¤§åŒå³°**
            const dist1 = Math.sqrt(tx*tx / 1.4**2 + ty*ty / 1.8**2);
            const dist2 = Math.sqrt((tx - 0.8 + wiggle)**2 / 0.9**2 + (ty + 0.6)**2 / 1.1**2);
            let val = Math.max( Math.exp(-dist1 * 2.2), Math.exp(-dist2 * 2.5) * 0.9 );

            val *= (0.82 + noise(dx*0.6 + time * 4, dy*0.6 + time * 4, seed) * 0.36);
            val *= (0.94 + noise(dx*1.2, dy*1.2, seed + 100 + time*6) * 0.12);
            val *= force * (0.99 + Math.sin(time * 8 + seed) * 0.1);

            return Math.max(0, val);
        }

        function resize() {
            const rect = canvas.getBoundingClientRect();
            dpr = window.devicePixelRatio || 1;
            const width = window.innerWidth * dpr;
            const height = window.innerHeight * dpr;

            canvas.width = width;
            canvas.height = height;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';

            ctx.scale(dpr, dpr);

            const size = Math.min(window.innerWidth, window.innerHeight);
            pixelSize = size / GRID_SIZE; // **~85-130px æ ¸çˆ†ï¼**
            offsetX = (window.innerWidth - size) / 2;
            offsetY = (window.innerHeight - size) / 2;

            pixelInfoEl.textContent = Math.round(pixelSize) + 'px';
        }

        function getTouchPos(touch) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: ((touch.clientX - rect.left) - offsetX) / pixelSize,
                y: ((touch.clientY - rect.top) - offsetY) / pixelSize
            };
        }

        function onTouchStart(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                const pos = getTouchPos(touch);
                const seed = Date.now() * 0.001 + touch.identifier * 100;
                const force = 0.8 + noise(seed + 300) * 0.4;
                touches.set(touch.identifier, { centerX: pos.x, centerY: pos.y, seed, force });
            }
            updateDisplay();
        }

        function onTouchMove(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                const touchData = touches.get(touch.identifier);
                if (touchData) {
                    const pos = getTouchPos(touch);
                    touchData.centerX = pos.x;
                    touchData.centerY = pos.y;
                    touchData.force = 0.7 + Math.sin(Date.now() * 0.007 + touch.identifier) * 0.3;
                }
            }
            updateDisplay();
        }

        function onTouchEnd(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                touches.delete(touch.identifier);
            }
            updateDisplay();
        }

        function updateDisplay() {
            touchCountEl.textContent = touches.size;
            let totalArea = 0;
            touches.forEach(t => totalArea += t.force * 800); // è°ƒæ•´æ¯”ä¾‹
            totalAreaEl.textContent = Math.floor(totalArea);
        }

        function render() {
            const time = (Date.now() - startTime) * 0.001;

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);

            const gridLeft = offsetX, gridTop = offsetY;
            for (let gy = 0; gy < GRID_SIZE; gy++) {
                for (let gx = 0; gx < GRID_SIZE; gx++) {
                    let maxBright = 0;
                    let closestTouchId = -1;
                    let minDist = Infinity;

                    touches.forEach((touch, id) => {
                        const dx = (gx + 0.5) - touch.centerX;
                        const dy = (gy + 0.5) - touch.centerY;
                        const dist = Math.sqrt(dx*dx + dy*dy);

                        const bright = computeDynamicShape(dx, dy, touch.seed, time, touch.force);

                        if (bright > maxBright) {
                            maxBright = bright;
                            if (dist < minDist) {
                                minDist = dist;
                                closestTouchId = id;
                            }
                        }
                    });

                    if (maxBright > 0.18) { // **æ›´é«˜é˜ˆå€¼ï¼Œå·¨ç –æ— å™ª**
                        const px = gridLeft + gx * pixelSize;
                        const py = gridTop + gy * pixelSize;
                        const gray = Math.floor(maxBright * 255);
                        ctx.fillStyle = `rgb(${gray},${gray},${gray})`;
                        ctx.fillRect(px, py, pixelSize, pixelSize);

                        if (closestTouchId !== -1 && minDist < 2.5) { // **é€‚é…å·¨æ ¼**
                            ctx.fillStyle = 'white';
                            ctx.fillRect(px + pixelSize*0.02, py + pixelSize*0.02, pixelSize*0.96, pixelSize*0.96);

                            ctx.strokeStyle = 'lime';
                            ctx.lineWidth = Math.max(12, pixelSize * 1.2); // **åŸå¢™ç²—ï¼**
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';
                            ctx.strokeRect(px + pixelSize*0.05, py + pixelSize*0.05, pixelSize*0.9, pixelSize*0.9);

                            ctx.fillStyle = 'black';
                            ctx.font = `${pixelSize*1.8}px bold Arial Black, Impact, monospace`; // **å·¨å·ï¼**
                            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                            ctx.fillText(
                                (Array.from(touches.keys()).indexOf(closestTouchId) + 1) + '',
                                px + pixelSize/2, py + pixelSize/2
                            );
                        }
                    }
                }
            }
        }

        // äº‹ä»¶
        canvas.addEventListener('touchstart', onTouchStart, { passive: false });
        canvas.addEventListener('touchmove', onTouchMove, { passive: false });
        canvas.addEventListener('touchend', onTouchEnd, { passive: false });
        canvas.addEventListener('touchcancel', onTouchEnd, { passive: false });

        // é¼ æ ‡
        let mouseActive = false;
        canvas.addEventListener('mousedown', (e) => {
            mouseActive = true;
            onTouchStart({ changedTouches: [{identifier: 999, clientX: e.clientX, clientY: e.clientY}] });
        });
        canvas.addEventListener('mousemove', (e) => {
            if (mouseActive) onTouchMove({ changedTouches: [{identifier: 999, clientX: e.clientX, clientY: e.clientY}] });
        });
        canvas.addEventListener('mouseup', () => {
            mouseActive = false;
            onTouchEnd({ changedTouches: [{identifier: 999}] });
        });

        window.addEventListener('resize', resize);
        window.addEventListener('orientationchange', () => setTimeout(resize, 100));
        resize();

        function loop() {
            updateDisplay();
            render();
            requestAnimationFrame(loop);
        }
        loop();
    </script>
</body>
</html>
